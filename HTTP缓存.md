### HTTP缓存

### 1. 什么是HTTP缓存？

* Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。

* 浏览器第一次打开一个网站的时候，需要加载对应资源，比如css，html，js，图片等,浏览器给我们缓存
* 浏览器第一次之后打开同样的一个网站，并不是把所有资源都加载过来，而是通过缓存帮助我们加载一些资源，整体网站的速度加载很快



### 2. 协商缓存

* 如果服务器使用的是协商缓存，那么客户端在请求的时候，会给客户端返回资源和资源标识(Etag，Last-Modified在响应头里)，浏览器会把返回的资源存在本地缓存中
* 下次再请求的时候，会带上资源标识，服务器根据这个标识判断，本地缓存资源是否和服务器资源相同，如果相同本地缓存没过期，不相同本地缓存就过期了
  * 在请求头中添加`if-Modified-since`(Last-Modified)
  * 在请求头中添加`if-None-Match`(Etag)
* 如果缓存过期了，服务器返回200状态码，更新最新的资源和资源标识，这就相当于发了一次完整请求，请求也会变慢
* 如果缓存没过期，服务器返回304状态码，客户端就会去本地缓存中拿资源，服务器只给客户端返回304，不需要返回文件，这次请求资源就是很小的

### 3. 强制缓存

* Cache-Control是一个相对时间，例如Cache-Control: max-age: 31536000，代表着资源的有效期是31536000秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。
* 客户端在第一次请求的时候，浏览器会给客户端返回资源，如果服务器觉得资源有必要缓存，会在响应头(response header)加上`Cache-Control`,可以设置max-age(31536000秒，对应一年)或者no-cache，
* Cache-Control 可以由多个字段组合而成，主要有以下几个取值：
  * **max-age**
    * 下一次请求的时候，会去根据max-age检查本地缓存是否过期，如果没有过期不会发送请求，从缓存里拿资源，页面加载速度很快，不需要请求，http请求是不稳定的，如果网络状态不好，可能等好几秒。此时状态码变为Status Code: 200 OK(from memory cache)
    * 如果本地缓存过期了，那么会去服务器重新发送请求，返回只有
  * **no-cache**，可以缓存，使用的时候，发送带验证器的请求到服务器
  * **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存
  * **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。
  * **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存
  * **must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。
* Cache-Control是服务器来通过响应投来决定的



* 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。
* 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age，需要和Last-modified结合使用。但cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
* 该字段会返回一个时间，比如Expires:Thu,31 Dec 2020 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2020年12月31日23点59分59秒之前都是有效的。但有一个明显的缺点，由于失效时间是一个绝对时间，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。

