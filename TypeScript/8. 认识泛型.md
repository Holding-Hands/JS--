#### 1. 认识泛型

```ts
function foo (n1: number) {
    return n1
}

foo(10)
// 以前我们定义一些函数，会给函数传参数，并且函数的参数也会定义相应的类型（此例为number）
// 这个时候函数的参数是由调用者决定（或者说是由外界决定）
// 那么油然而生一个想法，我们的参数类型是否也可以由外界决定

// 这里引出一个概念 【类型的参数化】
// 什么是类型的参数化？
// 在定义这个函数的时候，不决定参数的类型（此时参数就是不确定类型），而是让外界调用者以参数的形式来告知此时函数参数的类型

// 那么此时需要 foo 来接收类型的参数
// 在函数名的后面加个 <Type>，这里的Type变量可以随意命名，一般简写<T>
function foo<T> (n1: T) {
    return n1
}

// 1.调用方式一: 明确的传入类型
foo<number>(20)

// 2.调用方式二: 类型推导，这里推导的是字面量类型 50
foo(50)
```



#### 2. 泛型接收类型参数

* 泛型也是可以传入多个参数的
* 平时在开发中我们可能会看到一些常用的名称
  * T：Type的缩写，类型 
  * K、V：key和value的缩写，键值对
  * E：Element的缩写，元素
  * O：Object的缩写，对象
* 这些名字也不是固定的，我们也可以随意应用

```ts
function foo<T, E, O>(arg1: T, arg2: E, arg3?: O, ...args: T[]) {

}

foo<number, string, boolean>(10, "abc", true)
```



#### 3. 泛型接口的使用

```ts
// 泛型的默认类型
interface IPerson<T1 = string, T2 = number> {
  name: T1
  age: T2
}

// 当有默认类型，可以不传类型
const p: IPerson = {
  name: "qs",
  age: 18
}

```



#### 4. 泛型类的使用

```ts
class Point<T> {
  x: T
  y: T
  z: T

  constructor(x: T, y: T, z: T) {
    this.x = x
    this.y = y
    this.z = y
  }
}

const p1 = new Point("1.33.2", "2.22.3", "4.22.1") // 不写的话 且没有默认类型的话，默认会类型推导
const p2 = new Point<string>("1.33.2", "2.22.3", "4.22.1")
const p3: Point<string> = new Point("1.33.2", "2.22.3", "4.22.1")


// 以前使用数组类型
const names1: string[] = ["abc", "cba", "nba"]

// 现在可以使用泛型来定义数组类型
// 其实本质就是泛型类，Array类添加泛型<string> ，可以这样写，但不推荐(react jsx 有 <>，容易与这个冲突)
const names2: Array<string> = ["abc", "cba", "nba"] 
```



#### 5. 泛型的类型约束

```ts
// 1. 以前我们会这样写函数，但其实这样写不准确，比如，一个对象有length属性，我们也想获取，这个类型我们很难穷举完，这个时候就不要把类型写死，我们可以使用泛型进行约束
function getLength (arg: any[] | string) {
    return arg.length
}

// 2. 泛型约束 优化

// 定义必须有 length 属性的接口
interface ILength {
  length: number
}

// 使用 extends 对泛型进行约束，泛型必须有 length 属性
function getLength<T extends ILength>(arg: T) {
  return arg.length
}

getLength("abc")
getLength(["abc", "cba"])
getLength({ length: 100 })
```



#### 6. 命名空间

* TypeScript支持两种方式来控制我们的作用域

  * 模块化：每个文件可以是一个独立的模块，支持ES Module，也支持CommonJS
  * 命名空间：通过namespace来声明一个命名空间

  ```ts
  export function add(num1: number, num2: number) {
    return num1 + num2
  }
  
  export function sub(num1: number, num2: number) {
    return num1 - num2
  }
  ```

  

* 命名空间在TypeScript早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名 冲突的问题
* 使用 namespace 进行命名空间
* 一般不推荐使用，我们开发中尽量命名为不同变量名字

```ts
// 在b.ts  使用
import { time, price } from './a.ts'

console.log(time.format("11111111"))
console.log(price.format(123))

// a.ts
export namespace time {
  export function format(time: string) {
    return "2222-02-22"
  }

  // 如果命名空间内部定义的变量或者函数，没有使用 export 导出，外面不能访问该变量或函数，只能在命名空间内布访问
  const message: string = 'message'
  export function foo() {

  }

  export let name: string = "abc"
}

export namespace price {
  export function format(price: number) {
    return "99.99"
  }
}
```





#### 7.  类型的查找

*  之前我们所有的typescript中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型

```ts
const imgEl = document.querySelector('name') as HTMLImageElement
```

* 大家是否会奇怪，我们的HTMLImageElement类型来自哪里呢？
  * 其实这里就涉及到typescript对类型的管理和查找规则了 
*  这里先介绍另外的一种typescript文件：.d.ts文件（.d 其实是 declare 声明）
  * 我们之前编写的typescript文件都是 .ts 文件，这些文件最终会输出 .js 文件，也是我们通常编写代码的地方
  * 还有另外一种文件 .d.ts 文件，它是用来做类型的声明(declare)。 它仅仅用来做类型检测，告知typescript我们有哪些类型(告知TypeScript这些类型不要报错了)
*  那么typescript会在哪里查找我们的类型声明呢？
  *  内置类型声明
  * 外部定义类型声明
  * 自己定义类型声明



#### 8.  内置类型声明

* 内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件，包括比如Math、Date等内置类型，也包括DOM API，比如Window、Document等
* 内置类型声明通常在我们安装typescript的环境中会带有的
*  [TypeScript/lib at main · microsoft/TypeScript · GitHub](https://github.com/microsoft/TypeScript/tree/main/lib)，可以查看github   .d.ts 文件有很多



#### 9 . 外部定义类型声明

*  外部类型声明有两种：

  * 第三方库：axios库自己有类型声明，我们不需要声明，直接使用就好
* 安装相关库的类型声明
    * 社区有一个公有库DefinitelyTyped存放类型声明文件
      * 该库GitHub地址：https://github.com/DefinitelyTyped/DefinitelyTyped/ 
      * 该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search= 
    * 安装lodash的类型声明
      * npm i @types/lodash --save-dev

#### 10. 自定义类型声明

*  什么情况下需要自己来定义声明文件呢？
  * 使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash
  * 给自己的代码中声明一些类型，方便在其他地方直接进行使用，在项目中任何位置，一般和src平级或在src下面，编写一个以 .d.ts 结尾 就是一个声明文件。tsconfig.json后期会扫描到你这个文件
  * 在自己库中进行类型声明（编写.d.ts文件），比如axios