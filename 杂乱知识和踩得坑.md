### 杂乱知识和踩得坑

* 浏览器对象navigator，

  * 查看`ua navigator.userAgent`

* 对象值存在堆内存（简记：dui（堆）和对（dui）拼音一样）
  定义对象的时候 对象的变量存在栈内存中，而这个变量的引用就是该对象的内存地址（值），是存在堆内存中的

* `module.exports = {} `是`common.js`的导出方式 引入的话 const { 引入的名字 } = require('路径')

* `npx  vite` 相当于 `npm run serve`

* `npx vite build` 相当于 `npm run build`

* `npx vite preview` 测试打包后 有没有问题

  以上命令都是练习时 ，实际开发中我们使用脚本配置 比如` npm run build`

* 安装`vite` 脚手架 `npm install @vitejs/create-app -g`

* 使用`vite` 脚手架创建 `vue` 项目 `create-app` 项目名字

* 浏览器解析`dom`的时候 会将所有的元素，属性大写转为小写

* 打包之后 chunk-vendors下的打包的都是 第三方的文件

* 通过 import()函数 导入的模块， 后续`webpack`对其打包就会进行分包的操作





### 踩坑

* ant design vue 不回显的话 不用v-model

* ant design vue select下拉 可搜索

  ```js
  设置以下两个属性 option-filter-prop="children"   showSearch
                  <a-select
                    allowClear
                    option-filter-prop="children"
                    showSearch
                  >
                  </select>
  ```

* 循环当前行数据 尤其是 新增属性的时候 要用$set 要不然 不是响应

* enter-from 进入（入场）from从什么样的样式开始入场

* enter-to 入场 to最终到什么 样的状态

* ```
  moment(text).format('YYYY-MM-DD HH:mm:ss') // 24小时制
  moment(text).format('YYYY-MM-DD hh:mm:ss') // 12小时制
  ```



































项⽬难点：
例如很多组件都要使⽤Toast组件，不可能每个组件都要引⼊⼀下，那么采取组件封装的思想，在main.js中将其挂
载到原型上，然后回执⾏其install的⽅法，在install⽅法中导⼊toast组件。②由于采⽤组件复⽤的⽅式，那么例如在使⽤商品
展⽰的Item时，由于使⽤this.$bus.$emit和this.$bus.$on进⾏兄弟之间的传值那么，就有很多⻚⾯都会有监听图⽚加载完成，
那么离开这个组件不想去监听采⽤this.$bus.$off传递⼀个函数去取消具体哪⼀个⻚⾯的监听。

