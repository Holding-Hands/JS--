### 命令式与声明式

#### 1. 命令式框架

* 早年间流行的JQuery就是典型的命令式框架。命令式一大特点就是**关注过程**

  ```
  过程
  1. 获取 id 为 app 的 div 标签
  2. 设置文本内容为 Hello World
  3. 绑定点击事件
  4. 点击时弹出提示
  
  代码实现
  1. $('#app') // 获取 div 元素
  2. $('#app').text('Hello World') // 设置文本内容
  3. $('#app').text('Hello World').on('click', () => {
  	alert('ok')
  }) // 绑定点击事件
  
  可以看到，自然语言描述能够与代码产生一一对应的关系，代码描述的是做事的过程
  ```

  

#### 2. 声明式框架

* 而声明式更加**关注结果**，Vue就是典型的声明式框架

  ```js
  <div @click="() => alert('ok')">hello world</div>
  ```

* 这段类 HTML 的模板就是Vue.js实现如上JQuery的功能，至于如何实现这个 结果，我们并不关心，就像是我们喊嘿，siri，给我播放《浪子不懂爱》这首歌，我们不需要关心他内部怎么做，我们只关心，他给我播放这首歌这个结果。同样的道理。这就像是我们喊：嘿，VueJs,我想要一个div，内容是hello world，他有个事件绑定，至于怎么实现该 结果，则是由Vue.js帮我们完成的，换句话说Vuejs帮我们封装了过程。因此我们能够猜到 Vuejs内部实现一定是命令式的，而暴露给用户的却更加声明式



3. 命令式与声明式的优缺点

   * 假如我们将div标签的内容修改为 hello vue3，那么如何用命令式代码实现呢？

     ```js
     const el = document.querySelector('#app')
     el.textContent = 'hello vue'
     ```

   * 那么有没有更好的方法，比上面的代码性能更好？答案是没有！理论上命令式代码可以做到极致的性能优化，因为我们知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这点，因为他描述的结果：

     ```js
     // 之前
     <div @click="() => alert('ok')">hello world</div>
     // 之后
     <div @click="() => alert('ok')">hello vue3</div>
     ```

     对于框架来说，为了实现最优的更新性能，它需要找到前后的差异只，更新变化的地方，但是最终完成这次更新的代码仍然是：

     ```js
     const el = document.querySelector('#app')
     el.textContent = 'hello vue'
     ```

     如果我们把**直接修改的性能消耗**定义为A，把**找出差异的性能**消耗定义为B，那么由：

     1. 命令式代码的更新性能消耗 = A
     2. 声明式代码更新的性能消耗 = A + B

     可以看到，声明式代码会比命令式代码多出，B性能消耗，当 B 为 0 时，声明式代码与命令式代码的性能相同，但是无法做到超越，毕竟框架本身就是封装了命令式代码才是下面向用户的声明式。所以可以得出结论：**声明式代码的性能不由于命令式代码的性能**

   

   * 既然在性能层面，命令式代码是更好的选择，那么为什么Vue.js要选择声明式的设计方案呢？原因就在于声明式代码的**可维护性**更强，在开发中我么采用命令式代码开发的时候，我们需要维护实现目标的整个过程（包括元素创建，获取，更新，删除等），而声明式代码展示的就是我们要的结果，看上去更加直观。
   * 这就体现了框架设计上要做出可维护性，和性能之前的抉择，室友声明式提升可维护性，但也减少一些性能，而框架设计者要做的是：保持可维护性的同时让性能损失最小化。



#### 3. 虚拟DOM的作用

* 上面我们说到，声明式代码更新的性能消耗 = 直接修改的性能消耗 + 找出差异的性能，因此，如果我们能够最小化找出差异的性能消耗，就可以让声明式代码无限接近命令式代码的性能，而虚拟DOM的目的就是为了**最小化**找出差异这一步的性能消耗而出现的。
* 这里说一个结论 innerHTML性能 < 虚拟DOM < 原生的JavaScript(createElement)性能

 ![](https://s3.bmp.ovh/imgs/2022/09/22/14d474d5ce2cfb7c.png) 

* 上图可以看出两者差距不大，从宏观的角度只看数量级上的差异。如果在同一数量级，则认为没有差异。在创建页面的时候，都需要新建所有DOM元素。但只是创建页面的性能大差不差。

  

 ![](https://s3.bmp.ovh/imgs/2022/09/22/9c75624f3f03e168.png) 

* 可以发现在更新的时候虚拟DOM在创建JavaScript的运算会多出有一个Diff性能消耗，DOM在更新也面时只会更新必要的元素，但innerHTML需要全量更新，这时候虚拟DOM的优势就体现出来了。对于虚拟DOM来说，无论页面多大，都只会更新变化的内容，而对于innerHTML来说，页面越大，意味着更新时性能消耗越大。所以innerHTML性能 小于 虚拟DOM的性能小于原生JavaScript的性能

 ![](https://s3.bmp.ovh/imgs/2022/09/22/b9079dde4bde773e.png) 



* 总结： innerHTML性能 < 虚拟DOM < 原生的JavaScript(createElement)性能，不能简单下结论这与页面大小，变更大小，创建页面，更新页面都有关系，权衡之后发现虚拟DOM还是个不错的选择

